# Copyright (c) 2023 Adolfo Gómez García <dkmaster@dkmon.com>
#
# This software is released under the MIT License.
# https://opensource.org/licenses/MIT

import os.path
import sys
import tempfile
import asyncio
import logging
import typing
import threading
import asyncio

import win32serviceutil
import win32service
import pythoncom
import servicemanager

import win32timezone  # pylint: disable=unused-import

# TODO: use uvloop for faster async

logger = logging.getLogger(__name__)


class AsyncServer(threading.Thread):
    stop_event: threading.Event

    def __init__(self, stop_event: threading.Event) -> None:
        super().__init__()
        self.stop_event = stop_event

    async def main(self):
        """
        Simple example main task that runs forever until cancelled.
        """
        counter = 0
        while True:
            await asyncio.sleep(1)  # Until cancel is called
            logger.debug('* %d', counter)
            counter += 1

    async def _run(self):
        """
        This is the async runner for the AsyncServer.
        """
        task = asyncio.create_task(self.main())

        # This is a simpler alternative if nothing is to be done on the loop
        # self.stop_event.wait()
        while not self.stop_event.is_set():
            # Do something from while to while :)
            await asyncio.sleep(1)

        task.cancel()  # Cancel the running task

    def run(self):
        """
        This is the main entry point for the AsyncServer.
        """
        logger.debug('Starting AsyncServer')

        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)

        try:
            loop.run_until_complete(self._run())
        except Exception as e:
            logger.exception(e)

        logger.debug('Stopping AsyncServer')

        # Notify the service that we are done.
        self.stop_event.set()


class AsyncServerService(win32serviceutil.ServiceFramework):
    _svc_name_ = "AsyncServerService"
    _svc_display_name_ = "Async server runner for windows"
    _svc_description_ = (
        "Runs an async application on windows, using service framework. This is a simple example."
    )

    stop_event: threading.Event

    def __init__(self, args: typing.Any) -> None:
        win32serviceutil.ServiceFramework.__init__(self, args)
        # Create an event which we will use to wait on.
        # The "service stop" request will set this event.
        self.stop_event = threading.Event()

    def SvcStop(self):
        # Notifies the SCM that the service is stopping
        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)

        self.stop_event.set()

    def SvcDoRun(self):
        # Notifies the SCM that the service is started
        # Our start process is very fast, so we don't need to do anything special here, such as ReportServiceStatus(win32servie.SERVICE_START_PENDING)
        servicemanager.LogMsg(
            servicemanager.EVENTLOG_INFORMATION_TYPE, servicemanager.PYS_SERVICE_STARTED, (self._svc_name_, '')
        )

        logger.debug('Starting service')
        logger.debug('Initializing coms')
        pythoncom.CoInitialize()

        # Launch the AsyncServer on a thread
        async_server = AsyncServer(self.stop_event)
        async_server.start()

        # While hWaitStop hasn't been set by SvcStop, we loop and do stuff.
        while True:
            # Wait for service stop signal, if timeout, loop again
            if self.stop_event.wait(1) == True:
                break

            pythoncom.PumpWaitingMessages()

        logger.debug('Stopping service')

        # Wait for the AsyncServer to stop
        async_server.join()

        # Notifies the SCM that the service is stopped
        servicemanager.LogMsg(
            servicemanager.EVENTLOG_INFORMATION_TYPE, servicemanager.PYS_SERVICE_STOPPED, (self._svc_name_, '')
        )


if __name__ == '__main__':
    # Set logging file to be the same as the service name on temp folder
    logging.basicConfig(
        filename=os.path.join(tempfile.gettempdir(), 'async_service.log'),
        level=logging.DEBUG,
        format='%(asctime)s %(levelname)s %(name)s %(message)s',
    )
    # If started as a service, no extra arguments are passed (except for the service name)
    if len(sys.argv) == 1:
        # We make this this way so that we can run the service from an .exe generated by pyinstaller.
        servicemanager.Initialize()
        servicemanager.PrepareToHostSingle(AsyncServerService)
        servicemanager.StartServiceCtrlDispatcher()
    elif len(sys.argv) == 2 and sys.argv[1] == 'run':
        # Execute as application, not as service (helps on debugging)
        stop_event = threading.Event()
        async_server = AsyncServer(stop_event)
        async_server.run()  # Blocking call, not running on a thread
    else:
        # Process the command line arguments using the service framework.
        win32serviceutil.HandleCommandLine(AsyncServerService)
